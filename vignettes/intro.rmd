---
title: "Introduction to glmnetUtils"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo=FALSE}
library(glmnetUtils)
```

The glmnetUtils package provides some quality-of-life functions to streamline the process of fitting elastic net models with [glmnet](https://cran.r-project.org/package=glmnet). I wrote the package after a couple of projects where I found myself writing the same boilerplate code to convert a data frame into a predictor matrix and a response vector. In addition to this, it also provides a function `cvAlpha.glmnet` to do crossvalidation for both $\alpha$ and $\lambda$, as well as some utility functions.

## The formula interface

The interface that glmnetUtils provides is very much the same as for most modelling functions in R. To fit a model, you provide a formula and data frame:

```{r}
mtcarsMod <- glmnet(mpg ~ cyl + disp + hp, data=mtcars)
mtcarsMod
```

Under the hood, glmnetUtils creates a model matrix and response vector, and passes them to the glmnet package to do the actual model fitting. A simple `print` method is also provided, to show the main model details at a glance. I'll discuss the "sparse model matrix" and "use model.frame" options below.

You can supply any of the usual arguments to `glmnet`. For example, this fits a multinomial regression model to the iris data, using $\alpha = 0.5$ and a custom $\lambda$ sequence:

```{r}
glmnet(Species ~ ., data=iris, family="multinomial", alpha=0.5, lambda=seq(1e-4, 1, len=100))
```

Similarly, there is a formula interface for `cv.glmnet`:

```{r}
cv.glmnet(mpg ~ cyl + disp + hp, data=mtcars)
```

Predicting works as with regular R modelling functions: simply provide a data frame containing the new data. Again, you can supply any of the arguments to `predict.glmnet`, for example to get predictions for a specific value of $\lambda$.

```{r}
mtcarsPred <- predict(mtcarsMod, mtcars, s=1)  # predictions for a specific lambda
head(mtcarsPred)
```

If you want, you can still use the original model matrix-plus-response syntax:

```{r}
mtcarsX <- as.matrix(mtcars[c("cyl", "disp", "hp")])
mtcarsY <- mtcars[["mpg"]]
mtcarsMod2 <- glmnet(mtcarsX, mtcarsY)

summary(as.numeric(predict(mtcarsMod, mtcars) - 
                   predict(mtcarsMod2, mtcarsX)))
```

The resulting models are identical, in terms of the predictions they make and the regularisation parameters used.


## Generating the model matrix

There are two ways in which glmnetUtils can generate a model matrix out of a formula and data frame. The first is to use the standard R machinery comprising `model.frame` and `model.matrix`; and the second is to build the matrix one variable at a time.

### Using `model.frame`

This is the simpler option, and the one that is most compatible with other R modelling functions. The `model.frame` function takes a formula and data frame and returns a _model frame_: a data frame with special information attached that lets R make sense of the terms in the formula. For example, if a formula includes an interaction term, the model frame will specify which columns in the data relate to the interaction, and how they should be treated. Similarly, if the formula includes expressions like `exp(x)` or `I(x^2)` on the RHS, `model.frame` will evaluate these expressions and include them in the output.

The major disadvantage of using `model.frame` is that it generates a `terms` object, which encodes how variables and interactions are organised. One of the attributes of this object is a matrix with one row per variable, and one column per main effect and interaction. At minimum, this is (approximately) a $p \times p$ square matrix where $p$ is the number of main effects in the model. For wide datasets with $p > 10000$, this matrix can approach or exceed a gigabyte in size. Even if there is enough memory to store such an object, generating the model matrix can be very slow.

Another issue with the standard R approach is the treatment of factors. Normally, model.matrix will turn an $N$-level factor into an indicator matrix with $N-1$ columns, with one column being dropped. This is necessary for unregularised models as fit with `lm` and `glm`, since the full set of $N$ columns is linearly dependent. With the usual [treatment contrasts](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/contrasts.html), the interpretation is that the dropped column represents a baseline level, while the coefficients for the other columns represent the difference in the response relative to the baseline.

This may not be appropriate for a regularised model as fit with glmnet. The regularisation procedure shrinks the coefficients towards zero, which forces the estimated differences from the baseline to be smaller. But this only makes sense if the baseline level was chosen beforehand, or is otherwise meaningful as a default; otherwise it is effectively making the levels more similar to an arbitrarily chosen level.

### Manually building the model matrix

To deal with the problems above, glmnetUtils by default will avoid using `model.frame`, instead building up the model matrix term-by-term. This avoids the memory cost of creating a `terms` object, and can be noticeably faster than the standard approach. It will also include one column in the model matrix for _all_ levels in a factor; that is, no baseline level is assumed. In this situation, the coefficients represent differences from the overall mean response, and shrinking them to zero _is_ meaningful (usually).

The main downside of not using `model.frame` is that the formula can only be relatively simple. At the moment, only straightforward formulas like `y ~ x1 + x2 + ... + x_p` are handled by the code, where the x's are columns already present in the data. Interaction terms and computed expressions are not supported. Where possible, you should compute such expressions beforehand.

### Speed comparisons

To examine the speed impact of using `model.frame`, let's do some simple comparisons of run times. We'll generate sample datasets with 100, 1,000 and 10,000 predictors, and then run `glmnet` with both options for generating the model matrix.

<!--- don't eval: speed up vignette build, work around RTVS issue -->
```{r, eval=FALSE}
# generate sample (uncorrelated) data of a given size
makeSampleData <- function(N, P)
{
    X <- matrix(rnorm(N*P), nrow=N)
    data.frame(y=rnorm(N), X)
}

# test for three sizes: 100/1000/10000 predictors
df1 <- makeSampleData(N=1000, P=100)
df2 <- makeSampleData(N=1000, P=1000)
df3 <- makeSampleData(N=1000, P=10000)

library(microbenchmark)
res <- microbenchmark(
    glmnet(y ~ ., df1, use.model.frame=TRUE), 
    glmnet(y ~ ., df1, use.model.frame=FALSE), 
    glmnet(y ~ ., df2, use.model.frame=TRUE), 
    glmnet(y ~ ., df2, use.model.frame=FALSE), 
    glmnet(y ~ ., df3, use.model.frame=TRUE), 
    glmnet(y ~ ., df3, use.model.frame=FALSE),
    times=10 
)
print(res, unit="s", digits=2)
```

<!--- previous output -->
```
## Unit: seconds
##                                         expr   min     lq   mean median     uq    max neval
##   glmnet(y ~ ., df1, use.model.frame = TRUE) 0.021  0.022  0.024  0.023  0.023  0.035    10
##  glmnet(y ~ ., df1, use.model.frame = FALSE) 0.018  0.018  0.019  0.019  0.019  0.021    10
##   glmnet(y ~ ., df2, use.model.frame = TRUE) 4.526  4.614  4.839  4.833  4.987  5.305    10
##  glmnet(y ~ ., df2, use.model.frame = FALSE) 3.984  4.132  4.324  4.240  4.410  5.115    10
##   glmnet(y ~ ., df3, use.model.frame = TRUE) 9.792 10.321 10.881 10.765 11.693 12.216    10
##  glmnet(y ~ ., df3, use.model.frame = FALSE) 3.347  3.508  3.650  3.621  3.777  3.975    10
```

From this, we can see that for datasets with up to 1,000 predictors, both methods are about as fast as each other. However, for 10,000 predictors (not uncommon these days), the `model.frame` method takes three times as long as building the model matrix term by term.

### Sparse model matrix

As an option, glmnetUtils can also generate a _sparse_ model matrix, using the `sparse.model.matrix` function provided in the Matrix package. This works exactly the same as a regular model matrix, but can take up significantly less memory if many of its entries are zero. A scenario where this is the case would be where many of the predictors are factors, each with a large number of levels. This can be combined with both of the previously mentioned options for generating model matrices.

## Crossvalidation for $\alpha$

One piece missing from the standard glmnet package is a way of choosing $\alpha$, the elastic net mixing parameter, similar to how `cv.glmnet` chooses $\lambda$, the shrinkage parameter. To fix this, glmnetUtils provides the `cvAlpha.glmnet` function, which uses crossvalidation to examine the impact on the model of changing $\alpha$ and $\lambda$. The interface is the same as for the other functions:

```{r, echo=FALSE}
if(!file.exists("~/Leukemia.rdata"))
    download.file("http://web.stanford.edu/~hastie/glmnet/glmnetData/Leukemia.RData", "~/Leukemia.rdata", mode="wb")
```

```{r}
# Leukemia dataset from Trevor Hastie's website:
# http://web.stanford.edu/~hastie/glmnet/glmnetData/Leukemia.RData
load("~/Leukemia.rdata")
leuk <- do.call(data.frame, Leukemia)

leukMod <- cvAlpha.glmnet(y ~ ., data=leuk, family="binomial")
leukMod
```

`cvAlpha.glmnet` uses the algorithm described in the help for `cv.glmnet`, which is to fix the distribution of observations across folds and then call `cv.glmnet` in a loop with different values of $\alpha$. Optionally, you can parallelise this outer loop, by setting the `outerParallel` argument to a non-NULL value. Currently, glmnetUtils supports the following methods of parallelisation:

- Via `parLapply` in the parallel package. To use this, set `outerParallel` to a valid cluster object created by `makeCluster`. 
- Via `rxExec` as supplied by [Microsoft R Server's](https://www.microsoft.com/en-au/cloud-platform/r-server) RevoScaleR package. To use this, set `outerParallel` to a valid compute context created by `RxComputeContext`, or a character string specifying such a context. 

If the outer loop is run in parallel, `cvAlpha.glmnet` can check if the inner loop (over $\lambda$) is also set to run in parallel, and disable this if it would lead to contention for cores.

Because crossvalidation is often a statistically noisy procedure, it doesn't try to automatically choose $\alpha$ and $\lambda$ for you. Instead you can plot the output, to see how the results depend on the values of these parameters. Using this information, you can choose appropriate values for your data.

```{r, fig.height=5, fig.width=7}
plot(leukMod)
```

In this case, we see that values of $\alpha$ close to $1$ tend to lead to better accuracy. The curves don't have a well-defined minimum, but they do flatten out for lower values of $\lambda$. As the `cv.glmnet` documentation recommends though, it's a good idea to run `cvAlpha.glmnet` multiple times to reduce the impact of noise.

A `cvAlpha.glmnet` object contains a list of individual `cv.glmnet` objects, corresponding to the different $\alpha$ values tried. This lets you plot the crossvalidation results easily for a given $\alpha$:

```{r, fig.height=5, fig.width=7}
plot(leukMod$modlist[[10]])  # alpha = 0.729
```

## Conclusion

The glmnetUtils package is a way to improve quality of life for users of glmnet. As with many R packages, it's always under development; you can get the latest version from my [GitHub repo](https://github.com/Hong-Revo/glmnetUtils). If you find a bug, or if you want to suggest improvements to the package, please feel free to contact me at [hongooi@microsoft.com](mailto:hongooi@microsoft.com).

